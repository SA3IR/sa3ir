//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.6
//
// <auto-generated>
//
// Generated from file `Navigator.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Navigator_h__
#define __Navigator_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 6
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace RoboCompNavigator
{

class LocalNavigator;
class LocalNavigatorPrx;
class LocalNavigatorReportState;
class LocalNavigatorReportStatePrx;

}

namespace RoboCompNavigator
{

enum class navigationState : unsigned char
{
    IDLE,
    DRIVING,
    REACHED,
    FAILED
};

using cellVoltage = ::std::vector<float>;

struct RobotBatteryLevel
{
    float current;
    short lifePercent;
    short lifeTime;
    bool charging;
    bool powerSupplyPresent;
    ::RoboCompNavigator::cellVoltage cvoltage;
    float voltage;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const short&, const short&, const bool&, const bool&, const ::RoboCompNavigator::cellVoltage&, const float&> ice_tuple() const
    {
        return std::tie(current, lifePercent, lifeTime, charging, powerSupplyPresent, cvoltage, voltage);
    }
};

struct Stage
{
    int x;
    int z;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(x, z);
    }
};

using Trajectory = ::std::vector<Stage>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace RoboCompNavigator
{

class LocalNavigator : public virtual ::Ice::Object
{
public:

    using ProxyType = LocalNavigatorPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void stop(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_stop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool isActive(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_isActive(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool goTo(float x, float z, float angle, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_goTo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool goBackWardsTo(float x, float z, float angle, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_goBackWardsTo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool goToDockStation(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_goToDockStation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool goToBasePoint(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_goToBasePoint(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool rotate(float angle, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_rotate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string dockingStatus(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_dockingStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setOdometry(float x, float z, float angle, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setOdometry(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setPathVel(Trajectory path, float advVel, float rotVel, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setPathVel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setOrientation(float angle, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setOrientation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void forkLiftUp(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_forkLiftUp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void forkLiftDown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_forkLiftDown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class LocalNavigatorReportState : public virtual ::Ice::Object
{
public:

    using ProxyType = LocalNavigatorReportStatePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void reportRobotState(float distanceToGoal, float angToGoal, int timeElapsed, navigationState state, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_reportRobotState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reportRobotPose(float x, float z, float angle, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_reportRobotPose(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reportRobotBatteryLevel(RobotBatteryLevel batteryLevel, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_reportRobotBatteryLevel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reportForkLiftState(::std::string status, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_reportForkLiftState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reportAPTSensor(float distance, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_reportAPTSensor(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reportLimitSwitchState(bool state, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_reportLimitSwitchState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace RoboCompNavigator
{

class LocalNavigatorPrx : public virtual ::Ice::Proxy<LocalNavigatorPrx, ::Ice::ObjectPrx>
{
public:

    void stop(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LocalNavigatorPrx::_iceI_stop, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto stopAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LocalNavigatorPrx::_iceI_stop, context);
    }

    ::std::function<void()>
    stopAsync(::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_stop, context);
    }

    /// \cond INTERNAL
    void _iceI_stop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    bool isActive(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &LocalNavigatorPrx::_iceI_isActive, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto isActiveAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &LocalNavigatorPrx::_iceI_isActive, context);
    }

    ::std::function<void()>
    isActiveAsync(::std::function<void(bool)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_isActive, context);
    }

    /// \cond INTERNAL
    void _iceI_isActive(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool goTo(float x, float z, float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &LocalNavigatorPrx::_iceI_goTo, x, z, angle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto goToAsync(float x, float z, float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &LocalNavigatorPrx::_iceI_goTo, x, z, angle, context);
    }

    ::std::function<void()>
    goToAsync(float x, float z, float angle,
              ::std::function<void(bool)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_goTo, x, z, angle, context);
    }

    /// \cond INTERNAL
    void _iceI_goTo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, float, float, float, const ::Ice::Context&);
    /// \endcond

    bool goBackWardsTo(float x, float z, float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &LocalNavigatorPrx::_iceI_goBackWardsTo, x, z, angle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto goBackWardsToAsync(float x, float z, float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &LocalNavigatorPrx::_iceI_goBackWardsTo, x, z, angle, context);
    }

    ::std::function<void()>
    goBackWardsToAsync(float x, float z, float angle,
                       ::std::function<void(bool)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_goBackWardsTo, x, z, angle, context);
    }

    /// \cond INTERNAL
    void _iceI_goBackWardsTo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, float, float, float, const ::Ice::Context&);
    /// \endcond

    bool goToDockStation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &LocalNavigatorPrx::_iceI_goToDockStation, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto goToDockStationAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &LocalNavigatorPrx::_iceI_goToDockStation, context);
    }

    ::std::function<void()>
    goToDockStationAsync(::std::function<void(bool)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_goToDockStation, context);
    }

    /// \cond INTERNAL
    void _iceI_goToDockStation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool goToBasePoint(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &LocalNavigatorPrx::_iceI_goToBasePoint, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto goToBasePointAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &LocalNavigatorPrx::_iceI_goToBasePoint, context);
    }

    ::std::function<void()>
    goToBasePointAsync(::std::function<void(bool)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_goToBasePoint, context);
    }

    /// \cond INTERNAL
    void _iceI_goToBasePoint(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool rotate(float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &LocalNavigatorPrx::_iceI_rotate, angle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto rotateAsync(float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &LocalNavigatorPrx::_iceI_rotate, angle, context);
    }

    ::std::function<void()>
    rotateAsync(float angle,
                ::std::function<void(bool)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_rotate, angle, context);
    }

    /// \cond INTERNAL
    void _iceI_rotate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, float, const ::Ice::Context&);
    /// \endcond

    ::std::string dockingStatus(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &LocalNavigatorPrx::_iceI_dockingStatus, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto dockingStatusAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &LocalNavigatorPrx::_iceI_dockingStatus, context);
    }

    ::std::function<void()>
    dockingStatusAsync(::std::function<void(::std::string)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_dockingStatus, context);
    }

    /// \cond INTERNAL
    void _iceI_dockingStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    void setOdometry(float x, float z, float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LocalNavigatorPrx::_iceI_setOdometry, x, z, angle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setOdometryAsync(float x, float z, float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LocalNavigatorPrx::_iceI_setOdometry, x, z, angle, context);
    }

    ::std::function<void()>
    setOdometryAsync(float x, float z, float angle,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_setOdometry, x, z, angle, context);
    }

    /// \cond INTERNAL
    void _iceI_setOdometry(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, float, float, float, const ::Ice::Context&);
    /// \endcond

    void setPathVel(const Trajectory& path, float advVel, float rotVel, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LocalNavigatorPrx::_iceI_setPathVel, path, advVel, rotVel, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setPathVelAsync(const Trajectory& path, float advVel, float rotVel, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LocalNavigatorPrx::_iceI_setPathVel, path, advVel, rotVel, context);
    }

    ::std::function<void()>
    setPathVelAsync(const Trajectory& path, float advVel, float rotVel,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_setPathVel, path, advVel, rotVel, context);
    }

    /// \cond INTERNAL
    void _iceI_setPathVel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const Trajectory&, float, float, const ::Ice::Context&);
    /// \endcond

    bool setOrientation(float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &LocalNavigatorPrx::_iceI_setOrientation, angle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setOrientationAsync(float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &LocalNavigatorPrx::_iceI_setOrientation, angle, context);
    }

    ::std::function<void()>
    setOrientationAsync(float angle,
                        ::std::function<void(bool)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_setOrientation, angle, context);
    }

    /// \cond INTERNAL
    void _iceI_setOrientation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, float, const ::Ice::Context&);
    /// \endcond

    void forkLiftUp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LocalNavigatorPrx::_iceI_forkLiftUp, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto forkLiftUpAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LocalNavigatorPrx::_iceI_forkLiftUp, context);
    }

    ::std::function<void()>
    forkLiftUpAsync(::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_forkLiftUp, context);
    }

    /// \cond INTERNAL
    void _iceI_forkLiftUp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void forkLiftDown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LocalNavigatorPrx::_iceI_forkLiftDown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto forkLiftDownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LocalNavigatorPrx::_iceI_forkLiftDown, context);
    }

    ::std::function<void()>
    forkLiftDownAsync(::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorPrx::_iceI_forkLiftDown, context);
    }

    /// \cond INTERNAL
    void _iceI_forkLiftDown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    LocalNavigatorPrx() = default;
    friend ::std::shared_ptr<LocalNavigatorPrx> IceInternal::createProxy<LocalNavigatorPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class LocalNavigatorReportStatePrx : public virtual ::Ice::Proxy<LocalNavigatorReportStatePrx, ::Ice::ObjectPrx>
{
public:

    void reportRobotState(float distanceToGoal, float angToGoal, int timeElapsed, navigationState state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LocalNavigatorReportStatePrx::_iceI_reportRobotState, distanceToGoal, angToGoal, timeElapsed, state, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto reportRobotStateAsync(float distanceToGoal, float angToGoal, int timeElapsed, navigationState state, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LocalNavigatorReportStatePrx::_iceI_reportRobotState, distanceToGoal, angToGoal, timeElapsed, state, context);
    }

    ::std::function<void()>
    reportRobotStateAsync(float distanceToGoal, float angToGoal, int timeElapsed, navigationState state,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorReportStatePrx::_iceI_reportRobotState, distanceToGoal, angToGoal, timeElapsed, state, context);
    }

    /// \cond INTERNAL
    void _iceI_reportRobotState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, float, float, int, navigationState, const ::Ice::Context&);
    /// \endcond

    void reportRobotPose(float x, float z, float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LocalNavigatorReportStatePrx::_iceI_reportRobotPose, x, z, angle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto reportRobotPoseAsync(float x, float z, float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LocalNavigatorReportStatePrx::_iceI_reportRobotPose, x, z, angle, context);
    }

    ::std::function<void()>
    reportRobotPoseAsync(float x, float z, float angle,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorReportStatePrx::_iceI_reportRobotPose, x, z, angle, context);
    }

    /// \cond INTERNAL
    void _iceI_reportRobotPose(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, float, float, float, const ::Ice::Context&);
    /// \endcond

    void reportRobotBatteryLevel(const RobotBatteryLevel& batteryLevel, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LocalNavigatorReportStatePrx::_iceI_reportRobotBatteryLevel, batteryLevel, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto reportRobotBatteryLevelAsync(const RobotBatteryLevel& batteryLevel, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LocalNavigatorReportStatePrx::_iceI_reportRobotBatteryLevel, batteryLevel, context);
    }

    ::std::function<void()>
    reportRobotBatteryLevelAsync(const RobotBatteryLevel& batteryLevel,
                                 ::std::function<void()> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorReportStatePrx::_iceI_reportRobotBatteryLevel, batteryLevel, context);
    }

    /// \cond INTERNAL
    void _iceI_reportRobotBatteryLevel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const RobotBatteryLevel&, const ::Ice::Context&);
    /// \endcond

    void reportForkLiftState(const ::std::string& status, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LocalNavigatorReportStatePrx::_iceI_reportForkLiftState, status, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto reportForkLiftStateAsync(const ::std::string& status, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LocalNavigatorReportStatePrx::_iceI_reportForkLiftState, status, context);
    }

    ::std::function<void()>
    reportForkLiftStateAsync(const ::std::string& status,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorReportStatePrx::_iceI_reportForkLiftState, status, context);
    }

    /// \cond INTERNAL
    void _iceI_reportForkLiftState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void reportAPTSensor(float distance, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LocalNavigatorReportStatePrx::_iceI_reportAPTSensor, distance, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto reportAPTSensorAsync(float distance, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LocalNavigatorReportStatePrx::_iceI_reportAPTSensor, distance, context);
    }

    ::std::function<void()>
    reportAPTSensorAsync(float distance,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorReportStatePrx::_iceI_reportAPTSensor, distance, context);
    }

    /// \cond INTERNAL
    void _iceI_reportAPTSensor(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, float, const ::Ice::Context&);
    /// \endcond

    void reportLimitSwitchState(bool state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LocalNavigatorReportStatePrx::_iceI_reportLimitSwitchState, state, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto reportLimitSwitchStateAsync(bool state, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LocalNavigatorReportStatePrx::_iceI_reportLimitSwitchState, state, context);
    }

    ::std::function<void()>
    reportLimitSwitchStateAsync(bool state,
                                ::std::function<void()> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompNavigator::LocalNavigatorReportStatePrx::_iceI_reportLimitSwitchState, state, context);
    }

    /// \cond INTERNAL
    void _iceI_reportLimitSwitchState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, bool, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    LocalNavigatorReportStatePrx() = default;
    friend ::std::shared_ptr<LocalNavigatorReportStatePrx> IceInternal::createProxy<LocalNavigatorReportStatePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::RoboCompNavigator::navigationState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::RoboCompNavigator::RobotBatteryLevel>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 15;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompNavigator::RobotBatteryLevel, S>
{
    static void read(S* istr, ::RoboCompNavigator::RobotBatteryLevel& v)
    {
        istr->readAll(v.current, v.lifePercent, v.lifeTime, v.charging, v.powerSupplyPresent, v.cvoltage, v.voltage);
    }
};

template<>
struct StreamableTraits<::RoboCompNavigator::Stage>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompNavigator::Stage, S>
{
    static void read(S* istr, ::RoboCompNavigator::Stage& v)
    {
        istr->readAll(v.x, v.z);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace RoboCompNavigator
{

using LocalNavigatorPtr = ::std::shared_ptr<LocalNavigator>;
using LocalNavigatorPrxPtr = ::std::shared_ptr<LocalNavigatorPrx>;

using LocalNavigatorReportStatePtr = ::std::shared_ptr<LocalNavigatorReportState>;
using LocalNavigatorReportStatePrxPtr = ::std::shared_ptr<LocalNavigatorReportStatePrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace RoboCompNavigator
{

class LocalNavigator;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< LocalNavigator>&);
::IceProxy::Ice::Object* upCast(LocalNavigator*);
/// \endcond

class LocalNavigatorReportState;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< LocalNavigatorReportState>&);
::IceProxy::Ice::Object* upCast(LocalNavigatorReportState*);
/// \endcond

}

}

namespace RoboCompNavigator
{

class LocalNavigator;
/// \cond INTERNAL
::Ice::Object* upCast(LocalNavigator*);
/// \endcond
typedef ::IceInternal::Handle< LocalNavigator> LocalNavigatorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompNavigator::LocalNavigator> LocalNavigatorPrx;
typedef LocalNavigatorPrx LocalNavigatorPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LocalNavigatorPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class LocalNavigatorReportState;
/// \cond INTERNAL
::Ice::Object* upCast(LocalNavigatorReportState*);
/// \endcond
typedef ::IceInternal::Handle< LocalNavigatorReportState> LocalNavigatorReportStatePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompNavigator::LocalNavigatorReportState> LocalNavigatorReportStatePrx;
typedef LocalNavigatorReportStatePrx LocalNavigatorReportStatePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LocalNavigatorReportStatePtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace RoboCompNavigator
{

enum navigationState
{
    IDLE,
    DRIVING,
    REACHED,
    FAILED
};

typedef ::std::vector< ::Ice::Float> cellVoltage;

struct RobotBatteryLevel
{
    ::Ice::Float current;
    ::Ice::Short lifePercent;
    ::Ice::Short lifeTime;
    bool charging;
    bool powerSupplyPresent;
    ::RoboCompNavigator::cellVoltage cvoltage;
    ::Ice::Float voltage;
};

struct Stage
{
    ::Ice::Int x;
    ::Ice::Int z;

    bool operator==(const Stage& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(x != rhs_.x)
        {
            return false;
        }
        if(z != rhs_.z)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Stage& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(x < rhs_.x)
        {
            return true;
        }
        else if(rhs_.x < x)
        {
            return false;
        }
        if(z < rhs_.z)
        {
            return true;
        }
        else if(rhs_.z < z)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Stage& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Stage& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Stage& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Stage& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<Stage> Trajectory;

}

namespace RoboCompNavigator
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_stop.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_stop.
 */
class Callback_LocalNavigator_stop_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_stop_Base> Callback_LocalNavigator_stopPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_isActive.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_isActive.
 */
class Callback_LocalNavigator_isActive_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_isActive_Base> Callback_LocalNavigator_isActivePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goTo.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goTo.
 */
class Callback_LocalNavigator_goTo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_goTo_Base> Callback_LocalNavigator_goToPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goBackWardsTo.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goBackWardsTo.
 */
class Callback_LocalNavigator_goBackWardsTo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_goBackWardsTo_Base> Callback_LocalNavigator_goBackWardsToPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goToDockStation.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goToDockStation.
 */
class Callback_LocalNavigator_goToDockStation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_goToDockStation_Base> Callback_LocalNavigator_goToDockStationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goToBasePoint.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goToBasePoint.
 */
class Callback_LocalNavigator_goToBasePoint_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_goToBasePoint_Base> Callback_LocalNavigator_goToBasePointPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_rotate.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_rotate.
 */
class Callback_LocalNavigator_rotate_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_rotate_Base> Callback_LocalNavigator_rotatePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_dockingStatus.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_dockingStatus.
 */
class Callback_LocalNavigator_dockingStatus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_dockingStatus_Base> Callback_LocalNavigator_dockingStatusPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_setOdometry.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_setOdometry.
 */
class Callback_LocalNavigator_setOdometry_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_setOdometry_Base> Callback_LocalNavigator_setOdometryPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_setPathVel.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_setPathVel.
 */
class Callback_LocalNavigator_setPathVel_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_setPathVel_Base> Callback_LocalNavigator_setPathVelPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_setOrientation.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_setOrientation.
 */
class Callback_LocalNavigator_setOrientation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_setOrientation_Base> Callback_LocalNavigator_setOrientationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftUp.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_forkLiftUp.
 */
class Callback_LocalNavigator_forkLiftUp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_forkLiftUp_Base> Callback_LocalNavigator_forkLiftUpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftDown.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_forkLiftDown.
 */
class Callback_LocalNavigator_forkLiftDown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigator_forkLiftDown_Base> Callback_LocalNavigator_forkLiftDownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotState.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportRobotState.
 */
class Callback_LocalNavigatorReportState_reportRobotState_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigatorReportState_reportRobotState_Base> Callback_LocalNavigatorReportState_reportRobotStatePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotPose.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportRobotPose.
 */
class Callback_LocalNavigatorReportState_reportRobotPose_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigatorReportState_reportRobotPose_Base> Callback_LocalNavigatorReportState_reportRobotPosePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotBatteryLevel.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportRobotBatteryLevel.
 */
class Callback_LocalNavigatorReportState_reportRobotBatteryLevel_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigatorReportState_reportRobotBatteryLevel_Base> Callback_LocalNavigatorReportState_reportRobotBatteryLevelPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportForkLiftState.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportForkLiftState.
 */
class Callback_LocalNavigatorReportState_reportForkLiftState_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigatorReportState_reportForkLiftState_Base> Callback_LocalNavigatorReportState_reportForkLiftStatePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportAPTSensor.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportAPTSensor.
 */
class Callback_LocalNavigatorReportState_reportAPTSensor_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigatorReportState_reportAPTSensor_Base> Callback_LocalNavigatorReportState_reportAPTSensorPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportLimitSwitchState.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportLimitSwitchState.
 */
class Callback_LocalNavigatorReportState_reportLimitSwitchState_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LocalNavigatorReportState_reportLimitSwitchState_Base> Callback_LocalNavigatorReportState_reportLimitSwitchStatePtr;

}

namespace IceProxy
{

namespace RoboCompNavigator
{

class LocalNavigator : public virtual ::Ice::Proxy<LocalNavigator, ::IceProxy::Ice::Object>
{
public:

    void stop(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_stop(_iceI_begin_stop(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_stop(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_stop(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_stop(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_stop(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_stop(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_stop(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_stop(const ::RoboCompNavigator::Callback_LocalNavigator_stopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_stop(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_stop(const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_stopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_stop(context, cb, cookie);
    }

    void end_stop(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_stop(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool isActive(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_isActive(_iceI_begin_isActive(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_isActive(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_isActive(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isActive(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isActive(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isActive(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isActive(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isActive(const ::RoboCompNavigator::Callback_LocalNavigator_isActivePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isActive(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isActive(const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_isActivePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isActive(context, cb, cookie);
    }

    bool end_isActive(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_isActive(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool goTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_goTo(_iceI_begin_goTo(x, z, angle, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_goTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_goTo(x, z, angle, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_goTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goTo(x, z, angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goTo(x, z, angle, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::RoboCompNavigator::Callback_LocalNavigator_goToPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goTo(x, z, angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_goToPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goTo(x, z, angle, context, cb, cookie);
    }

    bool end_goTo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_goTo(::Ice::Float, ::Ice::Float, ::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool goBackWardsTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_goBackWardsTo(_iceI_begin_goBackWardsTo(x, z, angle, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_goBackWardsTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_goBackWardsTo(x, z, angle, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_goBackWardsTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goBackWardsTo(x, z, angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goBackWardsTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goBackWardsTo(x, z, angle, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goBackWardsTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::RoboCompNavigator::Callback_LocalNavigator_goBackWardsToPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goBackWardsTo(x, z, angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goBackWardsTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_goBackWardsToPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goBackWardsTo(x, z, angle, context, cb, cookie);
    }

    bool end_goBackWardsTo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_goBackWardsTo(::Ice::Float, ::Ice::Float, ::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool goToDockStation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_goToDockStation(_iceI_begin_goToDockStation(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_goToDockStation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_goToDockStation(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_goToDockStation(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goToDockStation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goToDockStation(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goToDockStation(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goToDockStation(const ::RoboCompNavigator::Callback_LocalNavigator_goToDockStationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goToDockStation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goToDockStation(const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_goToDockStationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goToDockStation(context, cb, cookie);
    }

    bool end_goToDockStation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_goToDockStation(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool goToBasePoint(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_goToBasePoint(_iceI_begin_goToBasePoint(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_goToBasePoint(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_goToBasePoint(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_goToBasePoint(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goToBasePoint(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goToBasePoint(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goToBasePoint(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goToBasePoint(const ::RoboCompNavigator::Callback_LocalNavigator_goToBasePointPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goToBasePoint(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_goToBasePoint(const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_goToBasePointPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_goToBasePoint(context, cb, cookie);
    }

    bool end_goToBasePoint(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_goToBasePoint(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool rotate(::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_rotate(_iceI_begin_rotate(angle, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_rotate(::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_rotate(angle, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_rotate(::Ice::Float angle, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_rotate(angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_rotate(::Ice::Float angle, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_rotate(angle, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_rotate(::Ice::Float angle, const ::RoboCompNavigator::Callback_LocalNavigator_rotatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_rotate(angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_rotate(::Ice::Float angle, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_rotatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_rotate(angle, context, cb, cookie);
    }

    bool end_rotate(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_rotate(::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string dockingStatus(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_dockingStatus(_iceI_begin_dockingStatus(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_dockingStatus(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_dockingStatus(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_dockingStatus(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dockingStatus(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dockingStatus(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dockingStatus(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dockingStatus(const ::RoboCompNavigator::Callback_LocalNavigator_dockingStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dockingStatus(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dockingStatus(const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_dockingStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dockingStatus(context, cb, cookie);
    }

    ::std::string end_dockingStatus(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_dockingStatus(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setOdometry(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setOdometry(_iceI_begin_setOdometry(x, z, angle, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setOdometry(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setOdometry(x, z, angle, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setOdometry(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setOdometry(x, z, angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setOdometry(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setOdometry(x, z, angle, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setOdometry(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::RoboCompNavigator::Callback_LocalNavigator_setOdometryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setOdometry(x, z, angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setOdometry(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_setOdometryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setOdometry(x, z, angle, context, cb, cookie);
    }

    void end_setOdometry(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setOdometry(::Ice::Float, ::Ice::Float, ::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void setPathVel(const ::RoboCompNavigator::Trajectory& path, ::Ice::Float advVel, ::Ice::Float rotVel, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_setPathVel(_iceI_begin_setPathVel(path, advVel, rotVel, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setPathVel(const ::RoboCompNavigator::Trajectory& path, ::Ice::Float advVel, ::Ice::Float rotVel, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setPathVel(path, advVel, rotVel, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPathVel(const ::RoboCompNavigator::Trajectory& path, ::Ice::Float advVel, ::Ice::Float rotVel, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPathVel(path, advVel, rotVel, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPathVel(const ::RoboCompNavigator::Trajectory& path, ::Ice::Float advVel, ::Ice::Float rotVel, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPathVel(path, advVel, rotVel, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPathVel(const ::RoboCompNavigator::Trajectory& path, ::Ice::Float advVel, ::Ice::Float rotVel, const ::RoboCompNavigator::Callback_LocalNavigator_setPathVelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPathVel(path, advVel, rotVel, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPathVel(const ::RoboCompNavigator::Trajectory& path, ::Ice::Float advVel, ::Ice::Float rotVel, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_setPathVelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPathVel(path, advVel, rotVel, context, cb, cookie);
    }

    void end_setPathVel(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setPathVel(const ::RoboCompNavigator::Trajectory&, ::Ice::Float, ::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool setOrientation(::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setOrientation(_iceI_begin_setOrientation(angle, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setOrientation(::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setOrientation(angle, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setOrientation(::Ice::Float angle, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setOrientation(angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setOrientation(::Ice::Float angle, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setOrientation(angle, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setOrientation(::Ice::Float angle, const ::RoboCompNavigator::Callback_LocalNavigator_setOrientationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setOrientation(angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setOrientation(::Ice::Float angle, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_setOrientationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setOrientation(angle, context, cb, cookie);
    }

    bool end_setOrientation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setOrientation(::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void forkLiftUp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_forkLiftUp(_iceI_begin_forkLiftUp(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_forkLiftUp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_forkLiftUp(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_forkLiftUp(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_forkLiftUp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_forkLiftUp(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_forkLiftUp(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_forkLiftUp(const ::RoboCompNavigator::Callback_LocalNavigator_forkLiftUpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_forkLiftUp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_forkLiftUp(const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_forkLiftUpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_forkLiftUp(context, cb, cookie);
    }

    void end_forkLiftUp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_forkLiftUp(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void forkLiftDown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_forkLiftDown(_iceI_begin_forkLiftDown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_forkLiftDown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_forkLiftDown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_forkLiftDown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_forkLiftDown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_forkLiftDown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_forkLiftDown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_forkLiftDown(const ::RoboCompNavigator::Callback_LocalNavigator_forkLiftDownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_forkLiftDown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_forkLiftDown(const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigator_forkLiftDownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_forkLiftDown(context, cb, cookie);
    }

    void end_forkLiftDown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_forkLiftDown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class LocalNavigatorReportState : public virtual ::Ice::Proxy<LocalNavigatorReportState, ::IceProxy::Ice::Object>
{
public:

    void reportRobotState(::Ice::Float distanceToGoal, ::Ice::Float angToGoal, ::Ice::Int timeElapsed, ::RoboCompNavigator::navigationState state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_reportRobotState(_iceI_begin_reportRobotState(distanceToGoal, angToGoal, timeElapsed, state, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_reportRobotState(::Ice::Float distanceToGoal, ::Ice::Float angToGoal, ::Ice::Int timeElapsed, ::RoboCompNavigator::navigationState state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_reportRobotState(distanceToGoal, angToGoal, timeElapsed, state, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportRobotState(::Ice::Float distanceToGoal, ::Ice::Float angToGoal, ::Ice::Int timeElapsed, ::RoboCompNavigator::navigationState state, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotState(distanceToGoal, angToGoal, timeElapsed, state, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRobotState(::Ice::Float distanceToGoal, ::Ice::Float angToGoal, ::Ice::Int timeElapsed, ::RoboCompNavigator::navigationState state, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotState(distanceToGoal, angToGoal, timeElapsed, state, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRobotState(::Ice::Float distanceToGoal, ::Ice::Float angToGoal, ::Ice::Int timeElapsed, ::RoboCompNavigator::navigationState state, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportRobotStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotState(distanceToGoal, angToGoal, timeElapsed, state, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRobotState(::Ice::Float distanceToGoal, ::Ice::Float angToGoal, ::Ice::Int timeElapsed, ::RoboCompNavigator::navigationState state, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportRobotStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotState(distanceToGoal, angToGoal, timeElapsed, state, context, cb, cookie);
    }

    void end_reportRobotState(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_reportRobotState(::Ice::Float, ::Ice::Float, ::Ice::Int, ::RoboCompNavigator::navigationState, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void reportRobotPose(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_reportRobotPose(_iceI_begin_reportRobotPose(x, z, angle, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_reportRobotPose(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_reportRobotPose(x, z, angle, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportRobotPose(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotPose(x, z, angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRobotPose(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotPose(x, z, angle, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRobotPose(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportRobotPosePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotPose(x, z, angle, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRobotPose(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportRobotPosePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotPose(x, z, angle, context, cb, cookie);
    }

    void end_reportRobotPose(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_reportRobotPose(::Ice::Float, ::Ice::Float, ::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void reportRobotBatteryLevel(const ::RoboCompNavigator::RobotBatteryLevel& batteryLevel, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_reportRobotBatteryLevel(_iceI_begin_reportRobotBatteryLevel(batteryLevel, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_reportRobotBatteryLevel(const ::RoboCompNavigator::RobotBatteryLevel& batteryLevel, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_reportRobotBatteryLevel(batteryLevel, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportRobotBatteryLevel(const ::RoboCompNavigator::RobotBatteryLevel& batteryLevel, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotBatteryLevel(batteryLevel, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRobotBatteryLevel(const ::RoboCompNavigator::RobotBatteryLevel& batteryLevel, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotBatteryLevel(batteryLevel, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRobotBatteryLevel(const ::RoboCompNavigator::RobotBatteryLevel& batteryLevel, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportRobotBatteryLevelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotBatteryLevel(batteryLevel, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRobotBatteryLevel(const ::RoboCompNavigator::RobotBatteryLevel& batteryLevel, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportRobotBatteryLevelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportRobotBatteryLevel(batteryLevel, context, cb, cookie);
    }

    void end_reportRobotBatteryLevel(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_reportRobotBatteryLevel(const ::RoboCompNavigator::RobotBatteryLevel&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void reportForkLiftState(const ::std::string& status, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_reportForkLiftState(_iceI_begin_reportForkLiftState(status, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_reportForkLiftState(const ::std::string& status, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_reportForkLiftState(status, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportForkLiftState(const ::std::string& status, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportForkLiftState(status, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportForkLiftState(const ::std::string& status, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportForkLiftState(status, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportForkLiftState(const ::std::string& status, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportForkLiftStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportForkLiftState(status, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportForkLiftState(const ::std::string& status, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportForkLiftStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportForkLiftState(status, context, cb, cookie);
    }

    void end_reportForkLiftState(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_reportForkLiftState(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void reportAPTSensor(::Ice::Float distance, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_reportAPTSensor(_iceI_begin_reportAPTSensor(distance, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_reportAPTSensor(::Ice::Float distance, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_reportAPTSensor(distance, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportAPTSensor(::Ice::Float distance, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportAPTSensor(distance, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportAPTSensor(::Ice::Float distance, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportAPTSensor(distance, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportAPTSensor(::Ice::Float distance, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportAPTSensorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportAPTSensor(distance, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportAPTSensor(::Ice::Float distance, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportAPTSensorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportAPTSensor(distance, context, cb, cookie);
    }

    void end_reportAPTSensor(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_reportAPTSensor(::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void reportLimitSwitchState(bool state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_reportLimitSwitchState(_iceI_begin_reportLimitSwitchState(state, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_reportLimitSwitchState(bool state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_reportLimitSwitchState(state, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportLimitSwitchState(bool state, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportLimitSwitchState(state, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportLimitSwitchState(bool state, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportLimitSwitchState(state, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportLimitSwitchState(bool state, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportLimitSwitchStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportLimitSwitchState(state, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reportLimitSwitchState(bool state, const ::Ice::Context& context, const ::RoboCompNavigator::Callback_LocalNavigatorReportState_reportLimitSwitchStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reportLimitSwitchState(state, context, cb, cookie);
    }

    void end_reportLimitSwitchState(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_reportLimitSwitchState(bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace RoboCompNavigator
{

class LocalNavigator : public virtual ::Ice::Object
{
public:

    typedef LocalNavigatorPrx ProxyType;
    typedef LocalNavigatorPtr PointerType;

    virtual ~LocalNavigator();

#ifdef ICE_CPP11_COMPILER
    LocalNavigator() = default;
    LocalNavigator(const LocalNavigator&) = default;
    LocalNavigator& operator=(const LocalNavigator&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void stop(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_stop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool isActive(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_isActive(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool goTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_goTo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool goBackWardsTo(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_goBackWardsTo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool goToDockStation(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_goToDockStation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool goToBasePoint(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_goToBasePoint(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool rotate(::Ice::Float angle, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_rotate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string dockingStatus(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_dockingStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setOdometry(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setOdometry(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void setPathVel(const Trajectory& path, ::Ice::Float advVel, ::Ice::Float rotVel, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setPathVel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setOrientation(::Ice::Float angle, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setOrientation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void forkLiftUp(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_forkLiftUp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void forkLiftDown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_forkLiftDown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const LocalNavigator& lhs, const LocalNavigator& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const LocalNavigator& lhs, const LocalNavigator& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class LocalNavigatorReportState : public virtual ::Ice::Object
{
public:

    typedef LocalNavigatorReportStatePrx ProxyType;
    typedef LocalNavigatorReportStatePtr PointerType;

    virtual ~LocalNavigatorReportState();

#ifdef ICE_CPP11_COMPILER
    LocalNavigatorReportState() = default;
    LocalNavigatorReportState(const LocalNavigatorReportState&) = default;
    LocalNavigatorReportState& operator=(const LocalNavigatorReportState&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void reportRobotState(::Ice::Float distanceToGoal, ::Ice::Float angToGoal, ::Ice::Int timeElapsed, navigationState state, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_reportRobotState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reportRobotPose(::Ice::Float x, ::Ice::Float z, ::Ice::Float angle, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_reportRobotPose(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reportRobotBatteryLevel(const RobotBatteryLevel& batteryLevel, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_reportRobotBatteryLevel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reportForkLiftState(const ::std::string& status, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_reportForkLiftState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reportAPTSensor(::Ice::Float distance, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_reportAPTSensor(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reportLimitSwitchState(bool state, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_reportLimitSwitchState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const LocalNavigatorReportState& lhs, const LocalNavigatorReportState& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const LocalNavigatorReportState& lhs, const LocalNavigatorReportState& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::RoboCompNavigator::navigationState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::RoboCompNavigator::RobotBatteryLevel>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 15;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompNavigator::RobotBatteryLevel, S>
{
    static void write(S* ostr, const ::RoboCompNavigator::RobotBatteryLevel& v)
    {
        ostr->write(v.current);
        ostr->write(v.lifePercent);
        ostr->write(v.lifeTime);
        ostr->write(v.charging);
        ostr->write(v.powerSupplyPresent);
        ostr->write(v.cvoltage);
        ostr->write(v.voltage);
    }
};

template<typename S>
struct StreamReader< ::RoboCompNavigator::RobotBatteryLevel, S>
{
    static void read(S* istr, ::RoboCompNavigator::RobotBatteryLevel& v)
    {
        istr->read(v.current);
        istr->read(v.lifePercent);
        istr->read(v.lifeTime);
        istr->read(v.charging);
        istr->read(v.powerSupplyPresent);
        istr->read(v.cvoltage);
        istr->read(v.voltage);
    }
};

template<>
struct StreamableTraits< ::RoboCompNavigator::Stage>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompNavigator::Stage, S>
{
    static void write(S* ostr, const ::RoboCompNavigator::Stage& v)
    {
        ostr->write(v.x);
        ostr->write(v.z);
    }
};

template<typename S>
struct StreamReader< ::RoboCompNavigator::Stage, S>
{
    static void read(S* istr, ::RoboCompNavigator::Stage& v)
    {
        istr->read(v.x);
        istr->read(v.z);
    }
};

}
/// \endcond

namespace RoboCompNavigator
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_stop.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_stop.
 */
template<class T>
class CallbackNC_LocalNavigator_stop : public Callback_LocalNavigator_stop_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LocalNavigator_stop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_stop.
 */
template<class T> Callback_LocalNavigator_stopPtr
newCallback_LocalNavigator_stop(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_stop<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_stop.
 */
template<class T> Callback_LocalNavigator_stopPtr
newCallback_LocalNavigator_stop(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_stop<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_stop.
 */
template<class T> Callback_LocalNavigator_stopPtr
newCallback_LocalNavigator_stop(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_stop<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_stop.
 */
template<class T> Callback_LocalNavigator_stopPtr
newCallback_LocalNavigator_stop(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_stop<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_stop.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_stop.
 */
template<class T, typename CT>
class Callback_LocalNavigator_stop : public Callback_LocalNavigator_stop_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LocalNavigator_stop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_stop.
 */
template<class T, typename CT> Callback_LocalNavigator_stopPtr
newCallback_LocalNavigator_stop(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_stop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_stop.
 */
template<class T, typename CT> Callback_LocalNavigator_stopPtr
newCallback_LocalNavigator_stop(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_stop<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_stop.
 */
template<class T, typename CT> Callback_LocalNavigator_stopPtr
newCallback_LocalNavigator_stop(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_stop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_stop.
 */
template<class T, typename CT> Callback_LocalNavigator_stopPtr
newCallback_LocalNavigator_stop(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_stop<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_isActive.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_isActive.
 */
template<class T>
class CallbackNC_LocalNavigator_isActive : public Callback_LocalNavigator_isActive_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LocalNavigator_isActive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_isActive(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_isActive.
 */
template<class T> Callback_LocalNavigator_isActivePtr
newCallback_LocalNavigator_isActive(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_isActive<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_isActive.
 */
template<class T> Callback_LocalNavigator_isActivePtr
newCallback_LocalNavigator_isActive(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_isActive<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_isActive.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_isActive.
 */
template<class T, typename CT>
class Callback_LocalNavigator_isActive : public Callback_LocalNavigator_isActive_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LocalNavigator_isActive(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_isActive(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_isActive.
 */
template<class T, typename CT> Callback_LocalNavigator_isActivePtr
newCallback_LocalNavigator_isActive(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_isActive<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_isActive.
 */
template<class T, typename CT> Callback_LocalNavigator_isActivePtr
newCallback_LocalNavigator_isActive(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_isActive<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goTo.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goTo.
 */
template<class T>
class CallbackNC_LocalNavigator_goTo : public Callback_LocalNavigator_goTo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LocalNavigator_goTo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_goTo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goTo.
 */
template<class T> Callback_LocalNavigator_goToPtr
newCallback_LocalNavigator_goTo(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_goTo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goTo.
 */
template<class T> Callback_LocalNavigator_goToPtr
newCallback_LocalNavigator_goTo(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_goTo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goTo.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goTo.
 */
template<class T, typename CT>
class Callback_LocalNavigator_goTo : public Callback_LocalNavigator_goTo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LocalNavigator_goTo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_goTo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goTo.
 */
template<class T, typename CT> Callback_LocalNavigator_goToPtr
newCallback_LocalNavigator_goTo(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_goTo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goTo.
 */
template<class T, typename CT> Callback_LocalNavigator_goToPtr
newCallback_LocalNavigator_goTo(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_goTo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goBackWardsTo.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goBackWardsTo.
 */
template<class T>
class CallbackNC_LocalNavigator_goBackWardsTo : public Callback_LocalNavigator_goBackWardsTo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LocalNavigator_goBackWardsTo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_goBackWardsTo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goBackWardsTo.
 */
template<class T> Callback_LocalNavigator_goBackWardsToPtr
newCallback_LocalNavigator_goBackWardsTo(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_goBackWardsTo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goBackWardsTo.
 */
template<class T> Callback_LocalNavigator_goBackWardsToPtr
newCallback_LocalNavigator_goBackWardsTo(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_goBackWardsTo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goBackWardsTo.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goBackWardsTo.
 */
template<class T, typename CT>
class Callback_LocalNavigator_goBackWardsTo : public Callback_LocalNavigator_goBackWardsTo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LocalNavigator_goBackWardsTo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_goBackWardsTo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goBackWardsTo.
 */
template<class T, typename CT> Callback_LocalNavigator_goBackWardsToPtr
newCallback_LocalNavigator_goBackWardsTo(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_goBackWardsTo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goBackWardsTo.
 */
template<class T, typename CT> Callback_LocalNavigator_goBackWardsToPtr
newCallback_LocalNavigator_goBackWardsTo(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_goBackWardsTo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goToDockStation.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goToDockStation.
 */
template<class T>
class CallbackNC_LocalNavigator_goToDockStation : public Callback_LocalNavigator_goToDockStation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LocalNavigator_goToDockStation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_goToDockStation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goToDockStation.
 */
template<class T> Callback_LocalNavigator_goToDockStationPtr
newCallback_LocalNavigator_goToDockStation(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_goToDockStation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goToDockStation.
 */
template<class T> Callback_LocalNavigator_goToDockStationPtr
newCallback_LocalNavigator_goToDockStation(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_goToDockStation<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goToDockStation.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goToDockStation.
 */
template<class T, typename CT>
class Callback_LocalNavigator_goToDockStation : public Callback_LocalNavigator_goToDockStation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LocalNavigator_goToDockStation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_goToDockStation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goToDockStation.
 */
template<class T, typename CT> Callback_LocalNavigator_goToDockStationPtr
newCallback_LocalNavigator_goToDockStation(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_goToDockStation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goToDockStation.
 */
template<class T, typename CT> Callback_LocalNavigator_goToDockStationPtr
newCallback_LocalNavigator_goToDockStation(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_goToDockStation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goToBasePoint.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goToBasePoint.
 */
template<class T>
class CallbackNC_LocalNavigator_goToBasePoint : public Callback_LocalNavigator_goToBasePoint_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LocalNavigator_goToBasePoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_goToBasePoint(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goToBasePoint.
 */
template<class T> Callback_LocalNavigator_goToBasePointPtr
newCallback_LocalNavigator_goToBasePoint(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_goToBasePoint<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goToBasePoint.
 */
template<class T> Callback_LocalNavigator_goToBasePointPtr
newCallback_LocalNavigator_goToBasePoint(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_goToBasePoint<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_goToBasePoint.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_goToBasePoint.
 */
template<class T, typename CT>
class Callback_LocalNavigator_goToBasePoint : public Callback_LocalNavigator_goToBasePoint_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LocalNavigator_goToBasePoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_goToBasePoint(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goToBasePoint.
 */
template<class T, typename CT> Callback_LocalNavigator_goToBasePointPtr
newCallback_LocalNavigator_goToBasePoint(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_goToBasePoint<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_goToBasePoint.
 */
template<class T, typename CT> Callback_LocalNavigator_goToBasePointPtr
newCallback_LocalNavigator_goToBasePoint(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_goToBasePoint<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_rotate.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_rotate.
 */
template<class T>
class CallbackNC_LocalNavigator_rotate : public Callback_LocalNavigator_rotate_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LocalNavigator_rotate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_rotate(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_rotate.
 */
template<class T> Callback_LocalNavigator_rotatePtr
newCallback_LocalNavigator_rotate(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_rotate<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_rotate.
 */
template<class T> Callback_LocalNavigator_rotatePtr
newCallback_LocalNavigator_rotate(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_rotate<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_rotate.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_rotate.
 */
template<class T, typename CT>
class Callback_LocalNavigator_rotate : public Callback_LocalNavigator_rotate_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LocalNavigator_rotate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_rotate(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_rotate.
 */
template<class T, typename CT> Callback_LocalNavigator_rotatePtr
newCallback_LocalNavigator_rotate(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_rotate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_rotate.
 */
template<class T, typename CT> Callback_LocalNavigator_rotatePtr
newCallback_LocalNavigator_rotate(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_rotate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_dockingStatus.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_dockingStatus.
 */
template<class T>
class CallbackNC_LocalNavigator_dockingStatus : public Callback_LocalNavigator_dockingStatus_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LocalNavigator_dockingStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_dockingStatus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_dockingStatus.
 */
template<class T> Callback_LocalNavigator_dockingStatusPtr
newCallback_LocalNavigator_dockingStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_dockingStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_dockingStatus.
 */
template<class T> Callback_LocalNavigator_dockingStatusPtr
newCallback_LocalNavigator_dockingStatus(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_dockingStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_dockingStatus.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_dockingStatus.
 */
template<class T, typename CT>
class Callback_LocalNavigator_dockingStatus : public Callback_LocalNavigator_dockingStatus_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LocalNavigator_dockingStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_dockingStatus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_dockingStatus.
 */
template<class T, typename CT> Callback_LocalNavigator_dockingStatusPtr
newCallback_LocalNavigator_dockingStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_dockingStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_dockingStatus.
 */
template<class T, typename CT> Callback_LocalNavigator_dockingStatusPtr
newCallback_LocalNavigator_dockingStatus(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_dockingStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_setOdometry.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_setOdometry.
 */
template<class T>
class CallbackNC_LocalNavigator_setOdometry : public Callback_LocalNavigator_setOdometry_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LocalNavigator_setOdometry(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOdometry.
 */
template<class T> Callback_LocalNavigator_setOdometryPtr
newCallback_LocalNavigator_setOdometry(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_setOdometry<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOdometry.
 */
template<class T> Callback_LocalNavigator_setOdometryPtr
newCallback_LocalNavigator_setOdometry(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_setOdometry<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOdometry.
 */
template<class T> Callback_LocalNavigator_setOdometryPtr
newCallback_LocalNavigator_setOdometry(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_setOdometry<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOdometry.
 */
template<class T> Callback_LocalNavigator_setOdometryPtr
newCallback_LocalNavigator_setOdometry(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_setOdometry<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_setOdometry.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_setOdometry.
 */
template<class T, typename CT>
class Callback_LocalNavigator_setOdometry : public Callback_LocalNavigator_setOdometry_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LocalNavigator_setOdometry(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOdometry.
 */
template<class T, typename CT> Callback_LocalNavigator_setOdometryPtr
newCallback_LocalNavigator_setOdometry(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_setOdometry<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOdometry.
 */
template<class T, typename CT> Callback_LocalNavigator_setOdometryPtr
newCallback_LocalNavigator_setOdometry(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_setOdometry<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOdometry.
 */
template<class T, typename CT> Callback_LocalNavigator_setOdometryPtr
newCallback_LocalNavigator_setOdometry(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_setOdometry<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOdometry.
 */
template<class T, typename CT> Callback_LocalNavigator_setOdometryPtr
newCallback_LocalNavigator_setOdometry(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_setOdometry<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_setPathVel.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_setPathVel.
 */
template<class T>
class CallbackNC_LocalNavigator_setPathVel : public Callback_LocalNavigator_setPathVel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LocalNavigator_setPathVel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setPathVel.
 */
template<class T> Callback_LocalNavigator_setPathVelPtr
newCallback_LocalNavigator_setPathVel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_setPathVel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setPathVel.
 */
template<class T> Callback_LocalNavigator_setPathVelPtr
newCallback_LocalNavigator_setPathVel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_setPathVel<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setPathVel.
 */
template<class T> Callback_LocalNavigator_setPathVelPtr
newCallback_LocalNavigator_setPathVel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_setPathVel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setPathVel.
 */
template<class T> Callback_LocalNavigator_setPathVelPtr
newCallback_LocalNavigator_setPathVel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_setPathVel<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_setPathVel.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_setPathVel.
 */
template<class T, typename CT>
class Callback_LocalNavigator_setPathVel : public Callback_LocalNavigator_setPathVel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LocalNavigator_setPathVel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setPathVel.
 */
template<class T, typename CT> Callback_LocalNavigator_setPathVelPtr
newCallback_LocalNavigator_setPathVel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_setPathVel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setPathVel.
 */
template<class T, typename CT> Callback_LocalNavigator_setPathVelPtr
newCallback_LocalNavigator_setPathVel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_setPathVel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setPathVel.
 */
template<class T, typename CT> Callback_LocalNavigator_setPathVelPtr
newCallback_LocalNavigator_setPathVel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_setPathVel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setPathVel.
 */
template<class T, typename CT> Callback_LocalNavigator_setPathVelPtr
newCallback_LocalNavigator_setPathVel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_setPathVel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_setOrientation.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_setOrientation.
 */
template<class T>
class CallbackNC_LocalNavigator_setOrientation : public Callback_LocalNavigator_setOrientation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LocalNavigator_setOrientation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setOrientation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOrientation.
 */
template<class T> Callback_LocalNavigator_setOrientationPtr
newCallback_LocalNavigator_setOrientation(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_setOrientation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOrientation.
 */
template<class T> Callback_LocalNavigator_setOrientationPtr
newCallback_LocalNavigator_setOrientation(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_setOrientation<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_setOrientation.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_setOrientation.
 */
template<class T, typename CT>
class Callback_LocalNavigator_setOrientation : public Callback_LocalNavigator_setOrientation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LocalNavigator_setOrientation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LocalNavigatorPrx proxy = LocalNavigatorPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setOrientation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOrientation.
 */
template<class T, typename CT> Callback_LocalNavigator_setOrientationPtr
newCallback_LocalNavigator_setOrientation(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_setOrientation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_setOrientation.
 */
template<class T, typename CT> Callback_LocalNavigator_setOrientationPtr
newCallback_LocalNavigator_setOrientation(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_setOrientation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftUp.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_forkLiftUp.
 */
template<class T>
class CallbackNC_LocalNavigator_forkLiftUp : public Callback_LocalNavigator_forkLiftUp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LocalNavigator_forkLiftUp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftUp.
 */
template<class T> Callback_LocalNavigator_forkLiftUpPtr
newCallback_LocalNavigator_forkLiftUp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_forkLiftUp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftUp.
 */
template<class T> Callback_LocalNavigator_forkLiftUpPtr
newCallback_LocalNavigator_forkLiftUp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_forkLiftUp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftUp.
 */
template<class T> Callback_LocalNavigator_forkLiftUpPtr
newCallback_LocalNavigator_forkLiftUp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_forkLiftUp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftUp.
 */
template<class T> Callback_LocalNavigator_forkLiftUpPtr
newCallback_LocalNavigator_forkLiftUp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_forkLiftUp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftUp.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_forkLiftUp.
 */
template<class T, typename CT>
class Callback_LocalNavigator_forkLiftUp : public Callback_LocalNavigator_forkLiftUp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LocalNavigator_forkLiftUp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftUp.
 */
template<class T, typename CT> Callback_LocalNavigator_forkLiftUpPtr
newCallback_LocalNavigator_forkLiftUp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_forkLiftUp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftUp.
 */
template<class T, typename CT> Callback_LocalNavigator_forkLiftUpPtr
newCallback_LocalNavigator_forkLiftUp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_forkLiftUp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftUp.
 */
template<class T, typename CT> Callback_LocalNavigator_forkLiftUpPtr
newCallback_LocalNavigator_forkLiftUp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_forkLiftUp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftUp.
 */
template<class T, typename CT> Callback_LocalNavigator_forkLiftUpPtr
newCallback_LocalNavigator_forkLiftUp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_forkLiftUp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftDown.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_forkLiftDown.
 */
template<class T>
class CallbackNC_LocalNavigator_forkLiftDown : public Callback_LocalNavigator_forkLiftDown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LocalNavigator_forkLiftDown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftDown.
 */
template<class T> Callback_LocalNavigator_forkLiftDownPtr
newCallback_LocalNavigator_forkLiftDown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_forkLiftDown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftDown.
 */
template<class T> Callback_LocalNavigator_forkLiftDownPtr
newCallback_LocalNavigator_forkLiftDown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_forkLiftDown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftDown.
 */
template<class T> Callback_LocalNavigator_forkLiftDownPtr
newCallback_LocalNavigator_forkLiftDown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_forkLiftDown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftDown.
 */
template<class T> Callback_LocalNavigator_forkLiftDownPtr
newCallback_LocalNavigator_forkLiftDown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigator_forkLiftDown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftDown.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigator_forkLiftDown.
 */
template<class T, typename CT>
class Callback_LocalNavigator_forkLiftDown : public Callback_LocalNavigator_forkLiftDown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LocalNavigator_forkLiftDown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftDown.
 */
template<class T, typename CT> Callback_LocalNavigator_forkLiftDownPtr
newCallback_LocalNavigator_forkLiftDown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_forkLiftDown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftDown.
 */
template<class T, typename CT> Callback_LocalNavigator_forkLiftDownPtr
newCallback_LocalNavigator_forkLiftDown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_forkLiftDown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftDown.
 */
template<class T, typename CT> Callback_LocalNavigator_forkLiftDownPtr
newCallback_LocalNavigator_forkLiftDown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_forkLiftDown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigator::begin_forkLiftDown.
 */
template<class T, typename CT> Callback_LocalNavigator_forkLiftDownPtr
newCallback_LocalNavigator_forkLiftDown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigator_forkLiftDown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotState.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportRobotState.
 */
template<class T>
class CallbackNC_LocalNavigatorReportState_reportRobotState : public Callback_LocalNavigatorReportState_reportRobotState_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LocalNavigatorReportState_reportRobotState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotState.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotStatePtr
newCallback_LocalNavigatorReportState_reportRobotState(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotState<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotState.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotStatePtr
newCallback_LocalNavigatorReportState_reportRobotState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotState<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotState.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotStatePtr
newCallback_LocalNavigatorReportState_reportRobotState(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotState<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotState.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotStatePtr
newCallback_LocalNavigatorReportState_reportRobotState(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotState<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotState.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportRobotState.
 */
template<class T, typename CT>
class Callback_LocalNavigatorReportState_reportRobotState : public Callback_LocalNavigatorReportState_reportRobotState_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LocalNavigatorReportState_reportRobotState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotStatePtr
newCallback_LocalNavigatorReportState_reportRobotState(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotStatePtr
newCallback_LocalNavigatorReportState_reportRobotState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotState<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotStatePtr
newCallback_LocalNavigatorReportState_reportRobotState(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotStatePtr
newCallback_LocalNavigatorReportState_reportRobotState(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotState<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotPose.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportRobotPose.
 */
template<class T>
class CallbackNC_LocalNavigatorReportState_reportRobotPose : public Callback_LocalNavigatorReportState_reportRobotPose_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LocalNavigatorReportState_reportRobotPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotPose.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotPosePtr
newCallback_LocalNavigatorReportState_reportRobotPose(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotPose<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotPose.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotPosePtr
newCallback_LocalNavigatorReportState_reportRobotPose(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotPose<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotPose.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotPosePtr
newCallback_LocalNavigatorReportState_reportRobotPose(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotPose<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotPose.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotPosePtr
newCallback_LocalNavigatorReportState_reportRobotPose(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotPose<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotPose.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportRobotPose.
 */
template<class T, typename CT>
class Callback_LocalNavigatorReportState_reportRobotPose : public Callback_LocalNavigatorReportState_reportRobotPose_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LocalNavigatorReportState_reportRobotPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotPose.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotPosePtr
newCallback_LocalNavigatorReportState_reportRobotPose(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotPose<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotPose.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotPosePtr
newCallback_LocalNavigatorReportState_reportRobotPose(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotPose<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotPose.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotPosePtr
newCallback_LocalNavigatorReportState_reportRobotPose(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotPose<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotPose.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotPosePtr
newCallback_LocalNavigatorReportState_reportRobotPose(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotPose<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotBatteryLevel.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportRobotBatteryLevel.
 */
template<class T>
class CallbackNC_LocalNavigatorReportState_reportRobotBatteryLevel : public Callback_LocalNavigatorReportState_reportRobotBatteryLevel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LocalNavigatorReportState_reportRobotBatteryLevel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotBatteryLevel.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotBatteryLevelPtr
newCallback_LocalNavigatorReportState_reportRobotBatteryLevel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotBatteryLevel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotBatteryLevel.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotBatteryLevelPtr
newCallback_LocalNavigatorReportState_reportRobotBatteryLevel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotBatteryLevel<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotBatteryLevel.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotBatteryLevelPtr
newCallback_LocalNavigatorReportState_reportRobotBatteryLevel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotBatteryLevel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotBatteryLevel.
 */
template<class T> Callback_LocalNavigatorReportState_reportRobotBatteryLevelPtr
newCallback_LocalNavigatorReportState_reportRobotBatteryLevel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportRobotBatteryLevel<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotBatteryLevel.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportRobotBatteryLevel.
 */
template<class T, typename CT>
class Callback_LocalNavigatorReportState_reportRobotBatteryLevel : public Callback_LocalNavigatorReportState_reportRobotBatteryLevel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LocalNavigatorReportState_reportRobotBatteryLevel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotBatteryLevel.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotBatteryLevelPtr
newCallback_LocalNavigatorReportState_reportRobotBatteryLevel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotBatteryLevel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotBatteryLevel.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotBatteryLevelPtr
newCallback_LocalNavigatorReportState_reportRobotBatteryLevel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotBatteryLevel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotBatteryLevel.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotBatteryLevelPtr
newCallback_LocalNavigatorReportState_reportRobotBatteryLevel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotBatteryLevel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportRobotBatteryLevel.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportRobotBatteryLevelPtr
newCallback_LocalNavigatorReportState_reportRobotBatteryLevel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportRobotBatteryLevel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportForkLiftState.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportForkLiftState.
 */
template<class T>
class CallbackNC_LocalNavigatorReportState_reportForkLiftState : public Callback_LocalNavigatorReportState_reportForkLiftState_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LocalNavigatorReportState_reportForkLiftState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportForkLiftState.
 */
template<class T> Callback_LocalNavigatorReportState_reportForkLiftStatePtr
newCallback_LocalNavigatorReportState_reportForkLiftState(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportForkLiftState<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportForkLiftState.
 */
template<class T> Callback_LocalNavigatorReportState_reportForkLiftStatePtr
newCallback_LocalNavigatorReportState_reportForkLiftState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportForkLiftState<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportForkLiftState.
 */
template<class T> Callback_LocalNavigatorReportState_reportForkLiftStatePtr
newCallback_LocalNavigatorReportState_reportForkLiftState(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportForkLiftState<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportForkLiftState.
 */
template<class T> Callback_LocalNavigatorReportState_reportForkLiftStatePtr
newCallback_LocalNavigatorReportState_reportForkLiftState(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportForkLiftState<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportForkLiftState.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportForkLiftState.
 */
template<class T, typename CT>
class Callback_LocalNavigatorReportState_reportForkLiftState : public Callback_LocalNavigatorReportState_reportForkLiftState_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LocalNavigatorReportState_reportForkLiftState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportForkLiftState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportForkLiftStatePtr
newCallback_LocalNavigatorReportState_reportForkLiftState(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportForkLiftState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportForkLiftState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportForkLiftStatePtr
newCallback_LocalNavigatorReportState_reportForkLiftState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportForkLiftState<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportForkLiftState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportForkLiftStatePtr
newCallback_LocalNavigatorReportState_reportForkLiftState(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportForkLiftState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportForkLiftState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportForkLiftStatePtr
newCallback_LocalNavigatorReportState_reportForkLiftState(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportForkLiftState<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportAPTSensor.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportAPTSensor.
 */
template<class T>
class CallbackNC_LocalNavigatorReportState_reportAPTSensor : public Callback_LocalNavigatorReportState_reportAPTSensor_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LocalNavigatorReportState_reportAPTSensor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportAPTSensor.
 */
template<class T> Callback_LocalNavigatorReportState_reportAPTSensorPtr
newCallback_LocalNavigatorReportState_reportAPTSensor(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportAPTSensor<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportAPTSensor.
 */
template<class T> Callback_LocalNavigatorReportState_reportAPTSensorPtr
newCallback_LocalNavigatorReportState_reportAPTSensor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportAPTSensor<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportAPTSensor.
 */
template<class T> Callback_LocalNavigatorReportState_reportAPTSensorPtr
newCallback_LocalNavigatorReportState_reportAPTSensor(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportAPTSensor<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportAPTSensor.
 */
template<class T> Callback_LocalNavigatorReportState_reportAPTSensorPtr
newCallback_LocalNavigatorReportState_reportAPTSensor(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportAPTSensor<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportAPTSensor.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportAPTSensor.
 */
template<class T, typename CT>
class Callback_LocalNavigatorReportState_reportAPTSensor : public Callback_LocalNavigatorReportState_reportAPTSensor_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LocalNavigatorReportState_reportAPTSensor(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportAPTSensor.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportAPTSensorPtr
newCallback_LocalNavigatorReportState_reportAPTSensor(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportAPTSensor<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportAPTSensor.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportAPTSensorPtr
newCallback_LocalNavigatorReportState_reportAPTSensor(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportAPTSensor<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportAPTSensor.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportAPTSensorPtr
newCallback_LocalNavigatorReportState_reportAPTSensor(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportAPTSensor<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportAPTSensor.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportAPTSensorPtr
newCallback_LocalNavigatorReportState_reportAPTSensor(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportAPTSensor<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportLimitSwitchState.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportLimitSwitchState.
 */
template<class T>
class CallbackNC_LocalNavigatorReportState_reportLimitSwitchState : public Callback_LocalNavigatorReportState_reportLimitSwitchState_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LocalNavigatorReportState_reportLimitSwitchState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportLimitSwitchState.
 */
template<class T> Callback_LocalNavigatorReportState_reportLimitSwitchStatePtr
newCallback_LocalNavigatorReportState_reportLimitSwitchState(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportLimitSwitchState<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportLimitSwitchState.
 */
template<class T> Callback_LocalNavigatorReportState_reportLimitSwitchStatePtr
newCallback_LocalNavigatorReportState_reportLimitSwitchState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportLimitSwitchState<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportLimitSwitchState.
 */
template<class T> Callback_LocalNavigatorReportState_reportLimitSwitchStatePtr
newCallback_LocalNavigatorReportState_reportLimitSwitchState(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportLimitSwitchState<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportLimitSwitchState.
 */
template<class T> Callback_LocalNavigatorReportState_reportLimitSwitchStatePtr
newCallback_LocalNavigatorReportState_reportLimitSwitchState(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LocalNavigatorReportState_reportLimitSwitchState<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportLimitSwitchState.
 * Create a wrapper instance by calling ::RoboCompNavigator::newCallback_LocalNavigatorReportState_reportLimitSwitchState.
 */
template<class T, typename CT>
class Callback_LocalNavigatorReportState_reportLimitSwitchState : public Callback_LocalNavigatorReportState_reportLimitSwitchState_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LocalNavigatorReportState_reportLimitSwitchState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportLimitSwitchState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportLimitSwitchStatePtr
newCallback_LocalNavigatorReportState_reportLimitSwitchState(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportLimitSwitchState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportLimitSwitchState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportLimitSwitchStatePtr
newCallback_LocalNavigatorReportState_reportLimitSwitchState(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportLimitSwitchState<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportLimitSwitchState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportLimitSwitchStatePtr
newCallback_LocalNavigatorReportState_reportLimitSwitchState(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportLimitSwitchState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompNavigator::LocalNavigatorReportState::begin_reportLimitSwitchState.
 */
template<class T, typename CT> Callback_LocalNavigatorReportState_reportLimitSwitchStatePtr
newCallback_LocalNavigatorReportState_reportLimitSwitchState(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LocalNavigatorReportState_reportLimitSwitchState<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
